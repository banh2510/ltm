<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>Cách Sử Dụng Async/Await trong JavaScript - lptriinhmng</title><meta name="description" content="Trong một thời gian rất dài, chúng ta phải dựa vào callbacks để làm việc với các đoạn code bất đồng bộ trong&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://banh2510.github.io/ltm/cach-su-dung-asyncawait-trong-javascript.html"><link rel="alternate" type="application/atom+xml" href="https://banh2510.github.io/ltm/feed.xml"><link rel="alternate" type="application/json" href="https://banh2510.github.io/ltm/feed.json"><meta property="og:title" content="Cách Sử Dụng Async/Await trong JavaScript"><meta property="og:image" content="https://banh2510.github.io/ltm/media/posts/5/15.webp"><meta property="og:image:width" content="1600"><meta property="og:image:height" content="983"><meta property="og:site_name" content="lptriinhmng"><meta property="og:description" content="Trong một thời gian rất dài, chúng ta phải dựa vào callbacks để làm việc với các đoạn code bất đồng bộ trong&hellip;"><meta property="og:url" content="https://banh2510.github.io/ltm/cach-su-dung-asyncawait-trong-javascript.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://banh2510.github.io/ltm/assets/css/fontawesome-all.min.css?v=85514f933f9e0b82460af63f1a403fa5"><link rel="stylesheet" href="https://banh2510.github.io/ltm/assets/css/style.css?v=a43d11e6c8e1828dd0b983b73b3cdb13"><noscript><link rel="stylesheet" href="https://banh2510.github.io/ltm/assets/css/noscript.css?v=efa867a99f5064d6729e4dc2008ad50b"></noscript><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://banh2510.github.io/ltm/cach-su-dung-asyncawait-trong-javascript.html"},"headline":"Cách Sử Dụng Async/Await trong JavaScript","datePublished":"2024-12-31T10:45+07:00","dateModified":"2024-12-31T21:59+07:00","image":{"@type":"ImageObject","url":"https://banh2510.github.io/ltm/media/posts/5/15.webp","height":983,"width":1600},"description":"Trong một thời gian rất dài, chúng ta phải dựa vào callbacks để làm việc với các đoạn code bất đồng bộ trong&hellip;","author":{"@type":"Person","name":"bnh","url":"https://banh2510.github.io/ltm/authors/bnh/"},"publisher":{"@type":"Organization","name":"bnh","logo":{"@type":"ImageObject","url":"https://banh2510.github.io/ltm/media/website/Brown_Vintage_Retro_Cake_and_Bakery_Business_Logo__1_-removebg-preview.png","height":500,"width":500}}}</script><style>#wrapper > .bg {
               background-image: url(https://banh2510.github.io/ltm/assets/images/overlay.png), linear-gradient(0deg, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url(https://banh2510.github.io/ltm/media/website/18.avif);
           }</style><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="is-preload post-template"><div id="wrapper"><header id="header"><a class="logo logo-image" href="https://banh2510.github.io/ltm/"><img src="https://banh2510.github.io/ltm/media/website/Brown_Vintage_Retro_Cake_and_Bakery_Business_Logo__1_-removebg-preview.png" alt="lptriinhmng" width="500" height="500"></a></header><nav id="nav"><ul class="links"><li><a href="https://banh2510.github.io/ltm/" target="_self">HOME</a></li><li><a href="https://banh2510.github.io/ltm/tags/blogs/" target="_self">BLOGS</a></li><li><a href="https://banh2510.github.io/ltm/profile.html" target="_self">PROFILE</a></li></ul></nav><main id="main"><article class="post"><header class="major"><time datetime="2024-12-31T10:45" class="date">December 31, 2024</time><h1>Cách Sử Dụng Async/Await trong JavaScript</h1><p class="post__inner"></p></header><figure class="image main"><img src="https://banh2510.github.io/ltm/media/posts/5/15.webp" srcset="https://banh2510.github.io/ltm/media/posts/5/responsive/15-xs.webp 300w, https://banh2510.github.io/ltm/media/posts/5/responsive/15-sm.webp 480w, https://banh2510.github.io/ltm/media/posts/5/responsive/15-md.webp 768w, https://banh2510.github.io/ltm/media/posts/5/responsive/15-lg.webp 1024w, https://banh2510.github.io/ltm/media/posts/5/responsive/15-xl.webp 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="983" width="1600" alt=""></figure><div class="post__inner post__entry"><ul><li><p>Trong một thời gian rất dài, chúng ta phải dựa vào callbacks để làm việc với các đoạn code bất đồng bộ trong javascript. Kết quả là, rất nhiều người trong chúng ta đã có những trải nghiệm kinh khủng khi phải đối mặt với các hàm trông như thế này.</p></li><li><p>Callback có rất nhiều nhược điểm. Khi ta có nhiều thao tác bất đồng bộ, các callback phải chờ nhau thực hiện, thời gian để hoàn thành sẽ bị kéo dài hơn. Ngoài ra, việc viết các callback lồng nhau cũng làm cho mã nguồn của ta rắc rối và khó bảo trì.</p></li><li><p>Thật may mắn, trong phiên bản ES6 , JavaScript đã được bổ xung thêm ( .then() ) Promise. Nó là một thay thế tuyệt vời cho callbacks và hầu hết cộng đồng nhanh chóng chuyển sang sử dụng nó để thay thế cho callbacks. Code mới của chúng ta gần giống với code cũ, kết quả là trông dễ theo dõi và bảo trì hơn. Tuy nhiên các vấn đề của callback vẫn chưa được giải quyết triệt để.</p></li><li><p>Cuối cùng, trong phiên bản ES7 gần đây nhất, Async / Await đã được bổ xung để việc viết code bất đồng bộ trong JavaScript tốt hơn, code dễ nhìn hơn và dễ sử dụng hơn.</p></li></ul><h1 id="_async--await-la-gi-0">Async / Await là gì?</h1><ul><li><p><strong>Async / Await</strong> là một tính năng của JavaScript giúp chúng ta làm việc với các hàm bất đồng bộ theo cách thú vị hơn và dễ hiểu hơn. Nó được xây dựng trên Promises và tương thích với tất cả các Promise dựa trên API. Trong đó:</p></li><li><p><strong>Async</strong> - khai báo một hàm bất đồng bộ (async function someName(){...}).</p><ul><li>Tự động biến đổi một hàm thông thường thành một Promise.</li><li>Khi gọi tới hàm async nó sẽ xử lý mọi thứ và được trả về kết quả trong hàm của nó.</li><li>Async cho phép sử dụng Await.</li></ul></li><li><p><strong>Await</strong> - tạm dừng việc thực hiện các hàm async. (Var result = await someAsyncCall ()</p><figure class="emoji"><img loading="lazy" draggable="false" src="https://twemoji.maxcdn.com/v/14.0.2/72x72/1f609.png" alt="😉" data-is-external-image="true"></figure>.<p></p><ul><li>Khi được đặt trước một Promise, nó sẽ đợi cho đến khi Promise kết thúc và trả về kết quả.</li><li>Await chỉ làm việc với Promises, nó không hoạt động với callbacks.</li><li>Await chỉ có thể được sử dụng bên trong các function async.</li></ul></li></ul><p>Dưới đây là một ví dụ đơn giản mà hy vọng sẽ rõ ràng những điều trên:</p><ul><li><p>Giả sử chúng ta muốn lấy một số tệp JSON từ máy chủ của mình. Chúng ta sẽ viết một hàm sử dụng thư viện axios và gửi yêu cầu HTTP GET đến Https://tutorialzine.com/misc/files/example.json . Chúng ta phải chờ đợi phản hồi từ máy chủ, đây là một yêu cầu HTTP không đồng bộ.</p></li><li><p>Dưới đây chúng ta sẽ viết cùng một chức năng với 2 cách khác nhau: cách thứ 1 với Promises, và cách thứ 2 với Async / Await</p></li></ul><div class="v-markdown-content-box" style="box-sizing: border-box; max-height: 300px; padding-bottom: 1rem; cursor: pointer; mask-image: linear-gradient(#000000 60%, transparent); color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;"><pre class="language-javascript" data-filename=""><code>// cách 1: 
    function getJSON() {

        // To make the function blocking we manually create a Promise.
        return new Promise( function(resolve) {
            axios.get('https://tutorialzine.com/misc/files/example.json')
                .then( function(json) {

                    // The data from the request is available in a .then block
                    // We return the result using resolve.
                    resolve(json);
                });
        });
    }
    // cách 2:
    // Async/Await approach

    // The async keyword will automatically create a new Promise and return it.
    async function getJSONAsync() {

        // The await keyword saves us from having to write a .then() block.
        let json = await axios.get('https://tutorialzine.com/misc/files/example.json');

        // The result of the GET request is available in the json variable.
        // We return it just like in a regular synchronous function.
        return json;
    }
</code></pre><button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="// cách 1: 
    function getJSON() {

        // To make the function blocking we manually create a Promise.
        return new Promise( function(resolve) {
            axios.get('https://tutorialzine.com/misc/files/example.json')
                .then( function(json) {

                    // The data from the request is available in a .then block
                    // We return the result using resolve.
                    resolve(json);
                });
        });
    }
    // cách 2:
    // Async/Await approach

    // The async keyword will automatically create a new Promise and return it.
    async function getJSONAsync() {

        // The await keyword saves us from having to write a .then() block.
        let json = await axios.get('https://tutorialzine.com/misc/files/example.json');

        // The result of the GET request is available in the json variable.
        // We return it just like in a regular synchronous function.
        return json;
    }
"></button><div class="v-content-flex-center"> </div></div><ul><li>Cả hai hàm bên trên đều thực hiện một chức năng hoàn toàn giống nhau - cả hai đều trả về Promises và giải quyết với phản hồi JSON từ <em>axios</em>. Tuy nhiên, phiên bản Async / Await ngắn hơn và dễ đọc hơn.</li><li>Chúng ta có thể gọi hàm async của chúng ta như sau:</li></ul><div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;"><pre class="language-none" data-filename=""><code>    getJSONAsync().then( function(result) {
        // Do something with result.
    });
</code></pre><button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="    getJSONAsync().then( function(result) {
        // Do something with result.
    });
"></button></div><h1 id="_vay-khi-co-async--await-co-lam-cho-promises-loi-thoi-1">Vậy khi có Async / Await có làm cho promises lỗi thời?</h1><ul><li><p>Không hoàn toàn. Khi làm việc với Async / Await, thật ra chúng ta vẫn đang sử dụng ngầm Promises. Vì thế, kể cả khi đang sử dụng Async / Await cần một sự hiểu biết tốt về Promises sẽ rất tốt cho chúng ta.</p></li><li><p>Ngoài ra, có những trường hợp mà Async / Await không sử dụng được và chúng ta phải sử dụng Promises. Ví dụ như khi chúng ta cần gọi nhiều thao tác bất đồng bộ và chờ cho tất cả chúng kết thúc. Nếu chúng ta thử và làm điều này với async và await, Điều gì sẽ xảy ra: Hãy xem ví dụ dưới đây các bạn sẽ thấy</p></li></ul><div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;"><pre class="language-none" data-filename=""><code>     async  function  getABC () {
      let A = await getValueA(); // getValueA takes 2 second to finish
      let B = await getValueB(); // getValueB takes 4 second to finish
      let C = await getValueC(); // getValueC takes 3 second to finish

      return A*B*C;
    }
</code></pre><button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="     async  function  getABC () {
      let A = await getValueA(); // getValueA takes 2 second to finish
      let B = await getValueB(); // getValueB takes 4 second to finish
      let C = await getValueC(); // getValueC takes 3 second to finish

      return A*B*C;
    }
"></button></div><ul><li>Mỗi lần gọi tới hàm await sẽ đợi cho đến khi hàm await trước đó kết thúc. Vì các wait sẽ đợi và thực hiện tuần tự từng cái một, toàn bộ chức năng sẽ mất 9 giây để thực hiện xong hàm từ đầu đến cuối (2 + 4 + 3).</li><li>Đây không phải là một giải pháp tối ưu vì A, B và C không phụ thuộc vào nhau, chúng ta không cần biết giá trị của A trước khi chúng ta có được B. Vì vậy, chúng ta có thể lấy chúng cùng một lúc và thời gian chờ đợi sẽ được giảm bớt đi.</li><li>Trong trường hợp như thế này, sử dụng Promise sẽ thích hợp hơn. Để gửi tất cả các yêu cầu cùng lúc, chúng ta sử dụng Promise.all(). Việc sử dụng Promise.all() sẽ đảm bảo chúng ta có tất cả các kết quả trước khi tiếp tục thực thi code, nhưng việc gọi đến các hàm bất đồng bộ sẽ được chạy song song mà không phải tuần tự từng cái một.</li></ul><div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;"><pre class="language-none" data-filename=""><code>    async  function  getABC () {
      // Promise.all() allows us to send all requests at the same time. 
      let results = await Promise.all([ getValueA, getValueB, getValueC ]); 

      return results.reduce((total,value) =&gt; total * value);
    }
</code></pre><button class="v-markdown-it-code-copy" style="box-sizing: border-box; border-radius: 5px; margin: 0px; font-family: inherit; font-size: inherit; line-height: inherit; overflow: visible; text-transform: none; appearance: button; position: absolute; display: flex; align-items: center; justify-content: center; top: 7.5px; right: 6px; cursor: pointer; outline: none; border: none; background: #655454; height: 25px; opacity: 0.5;" title="Sao chép" data-clipboard-text="    async  function  getABC () {
      // Promise.all() allows us to send all requests at the same time. 
      let results = await Promise.all([ getValueA, getValueB, getValueC ]); 

      return results.reduce((total,value) =&gt; total * value);
    }
"></button></div><ul><li>Bằng cách này, thời gian thực thi hàm sẽ mất it hơn. hàm getValueA và getValueC sẽ thực hiện xong trước khi getValueB xong. Thay vì phải mất 9 giây để chờ từng hàm trả về giá trị như trên, chúng ta sẽ chỉ mất 4 giây để chờ cả 3 hàm trả về giá trị.</li></ul><h1 id="_xu-ly-loi-trong-async--await-2">Xử lý lỗi trong Async / Await</h1><ul><li>Một điều tuyệt vời khác về Async / Await là nó cho phép chúng ta bắt các lỗi không mong đợi bằng cách sử dụng try / catch. Chúng ta chỉ cần để các await call của chúng ta vào trong khối try/catch như sau:</li></ul><div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;"><pre class="language-none" data-filename=""><code>    async function doSomethingAsync(){
        try {
            // This async call may fail.
            let result = await someAsyncCall();
        }
        catch(error) {
            // If it does we will catch the error here.
        }  
    }
</code></pre><button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="    async function doSomethingAsync(){
        try {
            // This async call may fail.
            let result = await someAsyncCall();
        }
        catch(error) {
            // If it does we will catch the error here.
        }  
    }
"></button></div><ul><li><p>Mệnh đề catch sẽ xử lý các lỗi gây ra bởi các hàm bất đồng bộ hoặc bất kỳ lỗi nào chúng ta có thể đã viết bên trong khối try.</p></li><li><p>Trong một vài tình huống, chúng ta cũng có thể bắt các lỗi khi đang thực hiện function async. Vì tất cả các hàm async đều trả về Promises, chúng ta chỉ cần gọi thêm hàm .catch() khi gọi chúng.</p></li></ul><div style="box-sizing: border-box; color: #1b1b1b; font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: #ffffff; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: relative;"><pre class="language-none" data-filename=""><code>    // Async function without a try/catch block.
    async function doSomethingAsync(){
        // This async call may fail.
        let result = await someAsyncCall();
        return result;  
    }

    // We catch the error upon calling the function.
    doSomethingAsync().
        .then(successHandler)
        .catch(errorHandler);
</code></pre><button class="v-markdown-it-code-copy" title="Sao chép" data-clipboard-text="    // Async function without a try/catch block.
    async function doSomethingAsync(){
        // This async call may fail.
        let result = await someAsyncCall();
        return result;  
    }

    // We catch the error upon calling the function.
    doSomethingAsync().
        .then(successHandler)
        .catch(errorHandler);
"></button></div><ul><li>Dựa vào các tình huống cụ thể, chúng ta sẽ sử dụng try/catch hoặc .catch() để bắt và xử lý lỗi. Tuy nhiên, chúng ta không nên sử dụng cả 2 cùng một lúc vì nó có thể dẫn đến các vấn đề không mong muốn.</li></ul><h1 id="_ho-tro-trinh-duyet-3">Hỗ trợ trình duyệt</h1><ul><li>Async / Await có thể sử dụng trong hầu hết các trình duyệt chính, ngoại trừ IE11 - tất cả các trình duyệt sẽ nhận ra mã async / await của bạn mà không cần các thư viện bên ngoài.</li><li>Nếu các bạn dùng Node cũng có sử dụng async từ Node 8 trở lên. Nó sẽ trở thành LTS vào cuối năm nay.</li><li>Nếu cái này không đáp ứng được nhu cầu của bạn, cũng có một số trình chuyển đổi JS như Babel và TypeScript và thư viện Node.js async/await cung cấp các phiên bản nền tảng riêng của tính năng này.</li></ul><h1 id="_phan-ket-luan-4">Phần kết luận</h1><ul><li><p>Với việc bổ sung Async / Await trong ngôn ngữ JavaScript có một bước nhảy vọt về khả năng dễ đọc và dễ sử dụng cho người mới bắt đầu với các lập trình JavaScript và người đã có kinh nghiệm.</p></li></ul></div><footer class="post__inner post__footer"><p class="post__last-updated">This article was updated on December 31, 2024</p><div class="post__share-tag-container"><div class="post__tag"><h3>Tagged in:</h3><ul><li><a href="https://banh2510.github.io/ltm/tags/blogs/">Blogs</a></li></ul></div><div class="post__share"><button class="post__share-button js-post__share-button icon" aria-label="Share button"><i class="fas fa-share-alt"></i></button><div class="post__share-popup js-post__share-popup"></div></div></div><div class="post__bio"><div><h3><a href="https://banh2510.github.io/ltm/authors/bnh/" class="invert" rel="author">bnh</a></h3></div></div></footer></article><div><strong>You should also read:</strong></div><div class="posts"><article><header><time datetime="2024-12-31T10:46" class="date">December 31, 2024</time><h2><a href="https://banh2510.github.io/ltm/cong-cu-debugging-va-testing-trong-javascript.html">DEBUG JAVASCRIPT – DỄ HAY KHÓ?</a></h2></header><a href="https://banh2510.github.io/ltm/cong-cu-debugging-va-testing-trong-javascript.html" class="image fit"><img src="https://banh2510.github.io/ltm/media/posts/10/20.png" srcset="https://banh2510.github.io/ltm/media/posts/10/responsive/20-xs.png 300w, https://banh2510.github.io/ltm/media/posts/10/responsive/20-sm.png 480w, https://banh2510.github.io/ltm/media/posts/10/responsive/20-md.png 768w, https://banh2510.github.io/ltm/media/posts/10/responsive/20-lg.png 1024w, https://banh2510.github.io/ltm/media/posts/10/responsive/20-xl.png 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="170" width="297" alt=""></a><p>Với mọi ngôn ngữ lập trình, debug là một hoạt động khó và mất nhiều thời gian nhất. Trong đó, debug JavaScript là khó khăn&hellip;</p><ul class="actions special"><li><a href="https://banh2510.github.io/ltm/cong-cu-debugging-va-testing-trong-javascript.html" class="button">Full Story</a></li></ul></article><article><header><time datetime="2024-12-31T10:46" class="date">December 31, 2024</time><h2><a href="https://banh2510.github.io/ltm/tim-hieu-ve-web-apis-trong-javascript.html">Tìm Hiểu về Web APIs trong JavaScript</a></h2></header><a href="https://banh2510.github.io/ltm/tim-hieu-ve-web-apis-trong-javascript.html" class="image fit"><img src="https://banh2510.github.io/ltm/media/posts/9/13.jpg" srcset="https://banh2510.github.io/ltm/media/posts/9/responsive/13-xs.jpg 300w, https://banh2510.github.io/ltm/media/posts/9/responsive/13-sm.jpg 480w, https://banh2510.github.io/ltm/media/posts/9/responsive/13-md.jpg 768w, https://banh2510.github.io/ltm/media/posts/9/responsive/13-lg.jpg 1024w, https://banh2510.github.io/ltm/media/posts/9/responsive/13-xl.jpg 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="526" width="1200" alt=""></a><p>Giới thiệu API Web Worker trong JavaScript Khi lập trình, dev không thể bắt người dùng phải chờ từng tác vụ này thực&hellip;</p><ul class="actions special"><li><a href="https://banh2510.github.io/ltm/tim-hieu-ve-web-apis-trong-javascript.html" class="button">Full Story</a></li></ul></article><article><header><time datetime="2024-12-31T10:45" class="date">December 31, 2024</time><h2><a href="https://banh2510.github.io/ltm/phat-trien-ung-dung-web-voi-javascript-frameworks.html">Top 10 JavaScript Framework phổ biến nhất cho phát triển web</a></h2></header><a href="https://banh2510.github.io/ltm/phat-trien-ung-dung-web-voi-javascript-frameworks.html" class="image fit"><img src="https://banh2510.github.io/ltm/media/posts/8/21.jpg" srcset="https://banh2510.github.io/ltm/media/posts/8/responsive/21-xs.jpg 300w, https://banh2510.github.io/ltm/media/posts/8/responsive/21-sm.jpg 480w, https://banh2510.github.io/ltm/media/posts/8/responsive/21-md.jpg 768w, https://banh2510.github.io/ltm/media/posts/8/responsive/21-lg.jpg 1024w, https://banh2510.github.io/ltm/media/posts/8/responsive/21-xl.jpg 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="162" width="311" alt=""></a><p>JavaScript là ngôn ngữ đa mô hình hỗ trợ các kiểu lập trình theo sự kiện, chức năng và bắt buộc (bao gồm hướng đối tượng và&hellip;</p><ul class="actions special"><li><a href="https://banh2510.github.io/ltm/phat-trien-ung-dung-web-voi-javascript-frameworks.html" class="button">Full Story</a></li></ul></article></div></main><footer id="copyright"><ul><li>© Massively</li><li>Design: <a href="https://html5up.net" target="_blank" rel="nofollow noopener">HTML5 UP</a></li><li>Powered by Publii</li></ul></footer></div><script src="https://banh2510.github.io/ltm/assets/js/jquery.min.js?v=c9771cc3e90e18f5336eedbd0fffb2cf"></script><script src="https://banh2510.github.io/ltm/assets/js/jquery.scrollex.min.js?v=f89065e3d988006af9791b44561d7c90"></script><script src="https://banh2510.github.io/ltm/assets/js/jquery.scrolly.min.js?v=1ed5a78bde1476875a40f6b9ff44fc14"></script><script src="https://banh2510.github.io/ltm/assets/js/browser.min.js?v=c07298dd19048a8a69ad97e754dfe8d0"></script><script src="https://banh2510.github.io/ltm/assets/js/breakpoints.min.js?v=81a479eb099e3b187613943b085923b8"></script><script src="https://banh2510.github.io/ltm/assets/js/util.min.js?v=4201a626f8c9b614a663b3a1d7d82615"></script><script src="https://banh2510.github.io/ltm/assets/js/main.min.js?v=56233c354bd814758be8bff42f7e13a5"></script><script>/*<![CDATA[*/var images=document.querySelectorAll("img[loading]");for(var i=0;i<images.length;i++){if(images[i].complete){images[i].classList.add("is-loaded")}else{images[i].addEventListener("load",function(){this.classList.add("is-loaded")},false)}};/*]]>*/</script></body></html>